# MDD 013_tuneup_004: Terraform Archive Creation Dependency Issue

## Problem Statement

**Issue**: Terraform deployment failing with "Archive creation error: could not archive missing directory: ./lambda_build"

**Error**: 
```
Error: Archive creation error
  with data.archive_file.lambda_deployment_package,
  on main.tf line 537, in data "archive_file" "lambda_deployment_package":
 537: data "archive_file" "lambda_deployment_package" {

error creating archive: error archiving directory: could not archive missing directory: ./lambda_build
```

**Root Cause**: Terraform dependency timing issue where `data.archive_file.lambda_deployment_package` tries to read `./lambda_build` directory before `null_resource.prepare_lambda_package` creates it.

**Impact**: GitHub Actions deployment fails, preventing Lambda function updates with Strands SDK.

**Context**: 
- MDD 013_tuneup_001 implemented `null_resource` approach ✅
- MDD 013_tuneup_002 fixed configuration issues ✅  
- MDD 013_tuneup_003 added Strands SDK to requirements ✅
- Terraform dependency execution order issue ❌

## Root Cause Analysis

### **Terraform Execution Order Issue**
```hcl
# This runs during terraform plan/apply
data "archive_file" "lambda_deployment_package" {
  depends_on = [null_resource.prepare_lambda_package]  # ✅ Dependency declared
  
  type        = "zip"
  source_dir  = "${path.module}/lambda_build"          # ❌ Directory doesn't exist yet
  output_path = "${path.module}/lambda_deployment.zip"
}

# This should run first but timing is inconsistent
resource "null_resource" "prepare_lambda_package" {
  provisioner "local-exec" {
    command = <<EOF
      mkdir -p ${path.module}/lambda_build              # Creates directory
      # ... copy operations
    EOF
  }
}
```

### **Terraform Data Source Behavior**
- **Data sources** are evaluated during **plan phase**
- **Resources** are created during **apply phase**  
- **depends_on** doesn't always guarantee execution order for data sources

## Solution Strategy

### **Approach**: Pre-Create Build Directory Structure

**Objective**: Ensure `lambda_build` directory exists before Terraform tries to archive it.

### **Selected Solution: Terraform Local File Resource**

**Why This Solution**: Use Terraform's `local_file` resource to create a placeholder file that ensures the directory structure exists before the archive operation. This approach is Terraform-native and guarantees proper dependency ordering.

### **Implementation**

```hcl
# Create build directory structure before archive operation
resource "local_file" "lambda_build_placeholder" {
  content  = "# Lambda build directory placeholder"
  filename = "${path.module}/lambda_build/.terraform_placeholder"
  
  # This ensures directory exists before any other operations
  provisioner "local-exec" {
    command = "mkdir -p ${path.module}/lambda_build"
  }
}

# Prepare Lambda package (depends on directory existing)
resource "null_resource" "prepare_lambda_package" {
  depends_on = [local_file.lambda_build_placeholder]
  
  provisioner "local-exec" {
    command = <<EOF
      # Directory already exists, safe to proceed
      cp -r ${path.root}/../../aws/lambda_orchestrator/* ${path.module}/lambda_build/
      cp -r ${path.root}/../../coderipple/src/* ${path.module}/lambda_build/src/
      # ... cleanup operations
    EOF
  }
  
  triggers = {
    lambda_handler_hash = filemd5("${path.root}/../../aws/lambda_orchestrator/src/lambda_handler.py")
    coderipple_agents_hash = sha1(join("", [
      for f in fileset("${path.root}/../../coderipple/src", "*.py") : 
      filemd5("${path.root}/../../coderipple/src/${f}")
    ]))
  }
}

# Archive the prepared package
data "archive_file" "lambda_deployment_package" {
  depends_on = [
    local_file.lambda_build_placeholder,
    null_resource.prepare_lambda_package
  ]
  
  type        = "zip"
  source_dir  = "${path.module}/lambda_build"
  output_path = "${path.module}/lambda_deployment.zip"
}
```

## Implementation Plan

### **Phase 1: Add Directory Pre-Creation**

**Step 1: Add Local File Resource**
- Create `local_file` resource to ensure directory exists
- Add proper dependency chain

**Step 2: Update Null Resource Dependencies**
- Make `null_resource.prepare_lambda_package` depend on directory creation
- Ensure proper execution order

**Step 3: Update Archive Dependencies**
- Add both resources to `archive_file` dependencies
- Guarantee directory exists before archiving

### **Phase 2: Test Dependency Chain**

**Step 4: Validate Terraform Plan**
- Run `terraform plan` to verify dependency order
- Ensure no missing directory errors

**Step 5: Test Archive Creation**
- Verify `lambda_build` directory is created
- Confirm archive operation succeeds

## Expected Outcomes

### **Immediate Resolution**
- **Directory Creation**: `lambda_build` directory exists before archive operation
- **Dependency Order**: Proper Terraform resource execution sequence
- **Archive Success**: Lambda deployment package created without errors
- **GitHub Actions**: Deployment pipeline completes successfully

### **Deployment Flow**
1. **local_file.lambda_build_placeholder** → Creates directory structure
2. **null_resource.prepare_lambda_package** → Populates directory with code
3. **data.archive_file.lambda_deployment_package** → Archives populated directory
4. **aws_lambda_function** → Deploys updated package with Strands SDK

## Success Criteria

- [x] Terraform plan executes without "missing directory" errors
- [x] `lambda_build` directory created before archive operation
- [x] Lambda deployment package includes CodeRipple source and Strands SDK
- [x] GitHub Actions deployment completes successfully
- [x] Lambda function updated with multi-agent capabilities

## Risk Assessment

### **Low Risk**
- Directory pre-creation (standard Terraform pattern)
- Dependency chain clarification (improves reliability)
- Local file resource usage (minimal overhead)

### **Mitigation**
- **Placeholder file**: Minimal impact, can be ignored in Lambda
- **Dependency ordering**: Explicit dependencies prevent race conditions
- **Backward compatibility**: Doesn't affect existing functionality

## Notes

- This is a **common Terraform pattern** for ensuring directory structure
- **local_file** resource is lightweight and reliable for dependency management
- **Explicit dependencies** prevent timing issues in CI/CD environments
- **Placeholder approach** is cleaner than pre-build scripts
