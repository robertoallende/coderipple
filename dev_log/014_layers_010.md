# MDD 014_layers_0010: Production Deployment and Validation

## Objective

Deploy Lambda Layers architecture to production environment with comprehensive validation, performance assessment, monitoring setup, and rollback procedures to ensure reliable operation of the multi-agent documentation system.

## Production Deployment Strategy

### Deployment Phases

#### Phase 1: Layer Deployment
1. **Dependencies Layer**: Deploy external dependencies layer
2. **Package Layer**: Deploy CodeRipple package layer
3. **Layer Validation**: Verify layer functionality in production environment
4. **Layer Versioning**: Establish version management and rollback procedures

#### Phase 2: Function Deployment
1. **Orchestrator Function**: Deploy layer-based orchestrator function
2. **Function Validation**: Verify function integration with layers
3. **API Gateway Integration**: Update webhook endpoint configuration
4. **End-to-End Testing**: Validate complete webhook processing pipeline

#### Phase 3: Multi-Lambda Preparation (Optional)
1. **Individual Agent Functions**: Deploy specialized agent functions
2. **Inter-Agent Coordination**: Validate multi-Lambda communication
3. **Performance Optimization**: Fine-tune resource allocation
4. **Production Monitoring**: Establish comprehensive observability

## Production Deployment Scripts

### Layer Deployment Script
```bash
#!/bin/bash
# scripts/deploy-layers-production.sh

set -e
source scripts/common-functions.sh

log_section "Production Layer Deployment"

# Configuration
ENVIRONMENT="production"
AWS_REGION="${AWS_REGION:-us-west-2}"
LAYER_VERSION_TAG=$(date +%Y%m%d-%H%M%S)

# Deploy Dependencies Layer
deploy_dependencies_layer() {
    log_step "Deploying CodeRipple Dependencies Layer to production"
    
    cd layers/dependencies
    
    # Build layer
    ./1-install.sh
    ./2-package.sh
    ./3-validate.sh
    
    # Deploy to AWS
    DEPENDENCIES_LAYER_ARN=$(aws lambda publish-layer-version \
        --layer-name "coderipple-dependencies-prod" \
        --description "CodeRipple external dependencies (Production)" \
        --zip-file fileb://coderipple-dependencies-layer.zip \
        --compatible-runtimes python3.13 \
        --compatible-architectures x86_64 \
        --region "$AWS_REGION" \
        --query 'LayerVersionArn' \
        --output text)
    
    log_success "Dependencies layer deployed: $DEPENDENCIES_LAYER_ARN"
    
    # Tag layer version
    aws lambda tag-resource \
        --resource "$DEPENDENCIES_LAYER_ARN" \
        --tags Environment="$ENVIRONMENT",Version="$LAYER_VERSION_TAG",Type="dependencies" \
        --region "$AWS_REGION"
    
    echo "$DEPENDENCIES_LAYER_ARN" > ../../deployment/dependencies-layer-arn.txt
    
    cd ../..
}

# Deploy Package Layer
deploy_package_layer() {
    log_step "Deploying CodeRipple Package Layer to production"
    
    cd layers/coderipple-package
    
    # Build layer
    ./1-install.sh
    ./2-package.sh
    ./3-validate.sh
    
    # Deploy to AWS
    PACKAGE_LAYER_ARN=$(aws lambda publish-layer-version \
        --layer-name "coderipple-package-prod" \
        --description "CodeRipple custom package (Production)" \
        --zip-file fileb://coderipple-package-layer.zip \
        --compatible-runtimes python3.13 \
        --compatible-architectures x86_64 \
        --region "$AWS_REGION" \
        --query 'LayerVersionArn' \
        --output text)
    
    log_success "Package layer deployed: $PACKAGE_LAYER_ARN"
    
    # Tag layer version
    aws lambda tag-resource \
        --resource "$PACKAGE_LAYER_ARN" \
        --tags Environment="$ENVIRONMENT",Version="$LAYER_VERSION_TAG",Type="package" \
        --region "$AWS_REGION"
    
    echo "$PACKAGE_LAYER_ARN" > ../../deployment/package-layer-arn.txt
    
    cd ../..
}

# Validate layers in production
validate_production_layers() {
    log_step "Validating layers in production environment"
    
    DEPENDENCIES_LAYER_ARN=$(cat deployment/dependencies-layer-arn.txt)
    PACKAGE_LAYER_ARN=$(cat deployment/package-layer-arn.txt)
    
    # Create test function to validate layers
    cat > deployment/layer-test-function.py << 'EOF'
import json

def lambda_handler(event, context):
    """Test function to validate layer functionality"""
    
    try:
        # Test dependencies layer
        import boto3
        import strands_agents
        import requests
        
        # Test package layer
        from coderipple.tourist_guide_agent import analyze_user_workflow_impact
        from coderipple.building_inspector_agent import analyze_system_changes
        from coderipple.historian_agent import analyze_decision_significance
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'status': 'success',
                'layers_functional': True,
                'boto3_version': boto3.__version__,
                'strands_version': strands_agents.__version__,
                'coderipple_agents': ['tourist_guide', 'building_inspector', 'historian']
            })
        }
        
    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({
                'status': 'error',
                'layers_functional': False,
                'error': str(e)
            })
        }
EOF
    
    # Package test function
    cd deployment
    zip layer-test-function.zip layer-test-function.py
    cd ..
    
    # Deploy test function
    TEST_FUNCTION_ARN=$(aws lambda create-function \
        --function-name "coderipple-layer-test-prod" \
        --runtime python3.13 \
        --role "arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/lambda-execution-role" \
        --handler "layer-test-function.lambda_handler" \
        --zip-file fileb://deployment/layer-test-function.zip \
        --layers "$DEPENDENCIES_LAYER_ARN" "$PACKAGE_LAYER_ARN" \
        --timeout 30 \
        --memory-size 512 \
        --region "$AWS_REGION" \
        --query 'FunctionArn' \
        --output text 2>/dev/null || \
    aws lambda update-function-code \
        --function-name "coderipple-layer-test-prod" \
        --zip-file fileb://deployment/layer-test-function.zip \
        --region "$AWS_REGION" \
        --query 'FunctionArn' \
        --output text)
    
    # Update layers on existing function
    aws lambda update-function-configuration \
        --function-name "coderipple-layer-test-prod" \
        --layers "$DEPENDENCIES_LAYER_ARN" "$PACKAGE_LAYER_ARN" \
        --region "$AWS_REGION" > /dev/null
    
    # Test layer functionality
    log_debug "Testing layer functionality..."
    sleep 5  # Allow function to update
    
    TEST_RESULT=$(aws lambda invoke \
        --function-name "coderipple-layer-test-prod" \
        --payload '{}' \
        --region "$AWS_REGION" \
        deployment/test-result.json \
        --query 'StatusCode' \
        --output text)
    
    if [ "$TEST_RESULT" = "200" ]; then
        RESPONSE_BODY=$(jq -r '.body' deployment/test-result.json | jq -r '.status')
        if [ "$RESPONSE_BODY" = "success" ]; then
            log_success "Production layer validation successful"
        else
            log_error "Layer validation failed: $(jq -r '.body' deployment/test-result.json)"
            exit 1
        fi
    else
        log_error "Layer test function invocation failed with status: $TEST_RESULT"
        exit 1
    fi
    
    # Cleanup test function
    aws lambda delete-function \
        --function-name "coderipple-layer-test-prod" \
        --region "$AWS_REGION" > /dev/null
    
    rm -f deployment/layer-test-function.py deployment/layer-test-function.zip deployment/test-result.json
}

# Create deployment manifest
create_deployment_manifest() {
    log_step "Creating deployment manifest"
    
    DEPENDENCIES_LAYER_ARN=$(cat deployment/dependencies-layer-arn.txt)
    PACKAGE_LAYER_ARN=$(cat deployment/package-layer-arn.txt)
    
    cat > deployment/production-deployment-manifest.json << EOF
{
  "deployment_id": "$(uuidgen)",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "environment": "$ENVIRONMENT",
  "region": "$AWS_REGION",
  "layers": {
    "dependencies": {
      "arn": "$DEPENDENCIES_LAYER_ARN",
      "version": "$LAYER_VERSION_TAG",
      "type": "external-dependencies"
    },
    "package": {
      "arn": "$PACKAGE_LAYER_ARN", 
      "version": "$LAYER_VERSION_TAG",
      "type": "coderipple-package"
    }
  },
  "validation": {
    "layers_tested": true,
    "functionality_verified": true,
    "deployment_successful": true
  }
}
EOF
    
    log_success "Deployment manifest created: deployment/production-deployment-manifest.json"
}

# Execute deployment steps
mkdir -p deployment
deploy_dependencies_layer
deploy_package_layer
validate_production_layers
create_deployment_manifest

log_section_complete "Production Layer Deployment"
```

### Function Deployment Script
```bash
#!/bin/bash
# scripts/deploy-function-production.sh

set -e
source scripts/common-functions.sh

log_section "Production Function Deployment"

# Configuration
ENVIRONMENT="production"
AWS_REGION="${AWS_REGION:-us-west-2}"
FUNCTION_NAME="coderipple-orchestrator-prod"

# Deploy orchestrator function
deploy_orchestrator_function() {
    log_step "Deploying CodeRipple Orchestrator Function to production"
    
    cd functions/orchestrator
    
    # Build function
    ./1-build.sh
    
    # Get layer ARNs from deployment
    DEPENDENCIES_LAYER_ARN=$(cat ../../deployment/dependencies-layer-arn.txt)
    PACKAGE_LAYER_ARN=$(cat ../../deployment/package-layer-arn.txt)
    
    # Deploy function
    FUNCTION_ARN=$(aws lambda create-function \
        --function-name "$FUNCTION_NAME" \
        --runtime python3.13 \
        --role "arn:aws:iam::$(aws sts get-caller-identity --query Account --output text):role/coderipple-lambda-execution-role" \
        --handler "lambda_function.lambda_handler" \
        --zip-file fileb://function.zip \
        --layers "$DEPENDENCIES_LAYER_ARN" "$PACKAGE_LAYER_ARN" \
        --timeout 900 \
        --memory-size 1024 \
        --environment Variables='{
            "CODERIPPLE_SOURCE_REPO":"'${GITHUB_REPO_OWNER}'/'${GITHUB_REPO_NAME}'",
            "CODERIPPLE_DOC_STRATEGY":"github_direct",
            "CODERIPPLE_ENABLED_AGENTS":"tourist_guide,building_inspector,historian",
            "CODERIPPLE_MIN_QUALITY_SCORE":"'${CODERIPPLE_MIN_QUALITY_SCORE}'",
            "CODERIPPLE_LAYER_BASED":"true",
            "ENVIRONMENT":"production"
        }' \
        --region "$AWS_REGION" \
        --query 'FunctionArn' \
        --output text 2>/dev/null || \
    aws lambda update-function-code \
        --function-name "$FUNCTION_NAME" \
        --zip-file fileb://function.zip \
        --region "$AWS_REGION" \
        --query 'FunctionArn' \
        --output text)
    
    # Update function configuration with layers
    aws lambda update-function-configuration \
        --function-name "$FUNCTION_NAME" \
        --layers "$DEPENDENCIES_LAYER_ARN" "$PACKAGE_LAYER_ARN" \
        --region "$AWS_REGION" > /dev/null
    
    log_success "Orchestrator function deployed: $FUNCTION_ARN"
    
    echo "$FUNCTION_ARN" > ../../deployment/function-arn.txt
    
    cd ../..
}

# Update API Gateway integration
update_api_gateway_integration() {
    log_step "Updating API Gateway integration"
    
    FUNCTION_ARN=$(cat deployment/function-arn.txt)
    
    # Get API Gateway ID
    API_ID=$(aws apigateway get-rest-apis \
        --query "items[?name=='coderipple-webhook-api-prod'].id" \
        --output text \
        --region "$AWS_REGION")
    
    if [ -n "$API_ID" ] && [ "$API_ID" != "None" ]; then
        # Update Lambda integration
        aws apigateway put-integration \
            --rest-api-id "$API_ID" \
            --resource-id "$(aws apigateway get-resources --rest-api-id "$API_ID" --query "items[?pathPart=='webhook'].id" --output text --region "$AWS_REGION")" \
            --http-method POST \
            --type AWS_PROXY \
            --integration-http-method POST \
            --uri "arn:aws:apigateway:$AWS_REGION:lambda:path/2015-03-31/functions/$FUNCTION_ARN/invocations" \
            --region "$AWS_REGION" > /dev/null
        
        # Deploy API changes
        aws apigateway create-deployment \
            --rest-api-id "$API_ID" \
            --stage-name prod \
            --region "$AWS_REGION" > /dev/null
        
        log_success "API Gateway integration updated"
    else
        log_warning "API Gateway not found, skipping integration update"
    fi
}

# Execute deployment steps
deploy_orchestrator_function
update_api_gateway_integration

log_section_complete "Production Function Deployment"
```

## Production Validation Framework

### End-to-End Validation Script
```bash
#!/bin/bash
# scripts/validate-production-deployment.sh

set -e
source scripts/common-functions.sh

log_section "Production Deployment Validation"

# Configuration
ENVIRONMENT="production"
AWS_REGION="${AWS_REGION:-us-west-2}"

# Test webhook processing
test_webhook_processing() {
    log_step "Testing webhook processing end-to-end"
    
    FUNCTION_ARN=$(cat deployment/function-arn.txt)
    
    # Create test webhook payload
    cat > deployment/test-webhook-payload.json << 'EOF'
{
  "repository": {
    "name": "test-repo",
    "full_name": "test-user/test-repo"
  },
  "commits": [
    {
      "id": "abc123def456",
      "message": "Add new feature for user authentication",
      "added": ["src/auth.py", "docs/authentication.md"],
      "modified": ["README.md"],
      "removed": []
    }
  ],
  "head_commit": {
    "id": "abc123def456",
    "message": "Add new feature for user authentication"
  }
}
EOF
    
    # Invoke function with test payload
    log_debug "Invoking function with test webhook payload..."
    
    INVOKE_RESULT=$(aws lambda invoke \
        --function-name "$(basename "$FUNCTION_ARN")" \
        --payload file://deployment/test-webhook-payload.json \
        --region "$AWS_REGION" \
        deployment/webhook-test-result.json \
        --query 'StatusCode' \
        --output text)
    
    if [ "$INVOKE_RESULT" = "200" ]; then
        # Parse response
        RESPONSE_STATUS=$(jq -r '.statusCode' deployment/webhook-test-result.json)
        RESPONSE_BODY=$(jq -r '.body' deployment/webhook-test-result.json)
        
        if [ "$RESPONSE_STATUS" = "200" ]; then
            AGENTS_INVOKED=$(echo "$RESPONSE_BODY" | jq -r '.agents_invoked // []' | jq -r 'length')
            AI_POWERED=$(echo "$RESPONSE_BODY" | jq -r '.ai_powered // false')
            
            log_success "Webhook processing successful"
            log_debug "Agents invoked: $AGENTS_INVOKED"
            log_debug "AI powered: $AI_POWERED"
        else
            log_error "Webhook processing failed with status: $RESPONSE_STATUS"
            log_debug "Response: $RESPONSE_BODY"
            exit 1
        fi
    else
        log_error "Function invocation failed with status: $INVOKE_RESULT"
        exit 1
    fi
    
    rm -f deployment/test-webhook-payload.json deployment/webhook-test-result.json
}

# Test layer functionality
test_layer_functionality() {
    log_step "Testing layer functionality in production"
    
    FUNCTION_ARN=$(cat deployment/function-arn.txt)
    
    # Create layer test payload
    cat > deployment/layer-test-payload.json << 'EOF'
{
  "test_type": "layer_functionality",
  "validate_imports": true
}
EOF
    
    # Test with minimal payload to check imports
    LAYER_TEST_RESULT=$(aws lambda invoke \
        --function-name "$(basename "$FUNCTION_ARN")" \
        --payload file://deployment/layer-test-payload.json \
        --region "$AWS_REGION" \
        deployment/layer-test-result.json \
        --query 'StatusCode' \
        --output text)
    
    if [ "$LAYER_TEST_RESULT" = "200" ]; then
        log_success "Layer functionality test completed"
    else
        log_error "Layer functionality test failed"
        cat deployment/layer-test-result.json
        exit 1
    fi
    
    rm -f deployment/layer-test-payload.json deployment/layer-test-result.json
}

# Performance testing
test_performance_metrics() {
    log_step "Testing performance metrics"
    
    FUNCTION_NAME=$(basename "$(cat deployment/function-arn.txt)")
    
    # Get recent invocation metrics
    DURATION_METRICS=$(aws cloudwatch get-metric-statistics \
        --namespace AWS/Lambda \
        --metric-name Duration \
        --dimensions Name=FunctionName,Value="$FUNCTION_NAME" \
        --start-time "$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ)" \
        --end-time "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
        --period 300 \
        --statistics Average,Maximum \
        --region "$AWS_REGION" \
        --query 'Datapoints[0].Average' \
        --output text)
    
    if [ "$DURATION_METRICS" != "None" ] && [ -n "$DURATION_METRICS" ]; then
        DURATION_MS=$(echo "$DURATION_METRICS" | cut -d'.' -f1)
        log_success "Average execution time: ${DURATION_MS}ms"
        
        if [ "$DURATION_MS" -lt 30000 ]; then  # Less than 30 seconds
            log_success "Performance within acceptable limits"
        else
            log_warning "Performance may need optimization: ${DURATION_MS}ms"
        fi
    else
        log_debug "No recent performance metrics available"
    fi
}

# Validate monitoring setup
validate_monitoring_setup() {
    log_step "Validating monitoring setup"
    
    FUNCTION_NAME=$(basename "$(cat deployment/function-arn.txt)")
    
    # Check CloudWatch log group
    LOG_GROUP="/aws/lambda/$FUNCTION_NAME"
    
    LOG_GROUP_EXISTS=$(aws logs describe-log-groups \
        --log-group-name-prefix "$LOG_GROUP" \
        --region "$AWS_REGION" \
        --query 'logGroups[0].logGroupName' \
        --output text 2>/dev/null || echo "None")
    
    if [ "$LOG_GROUP_EXISTS" != "None" ]; then
        log_success "CloudWatch log group exists: $LOG_GROUP"
    else
        log_warning "CloudWatch log group not found: $LOG_GROUP"
    fi
    
    # Check recent log entries
    RECENT_LOGS=$(aws logs describe-log-streams \
        --log-group-name "$LOG_GROUP" \
        --order-by LastEventTime \
        --descending \
        --max-items 1 \
        --region "$AWS_REGION" \
        --query 'logStreams[0].lastEventTime' \
        --output text 2>/dev/null || echo "None")
    
    if [ "$RECENT_LOGS" != "None" ]; then
        log_success "Recent log activity detected"
    else
        log_debug "No recent log activity"
    fi
}

# Execute validation steps
test_webhook_processing
test_layer_functionality
test_performance_metrics
validate_monitoring_setup

log_section_complete "Production Deployment Validation"
```

## Monitoring and Alerting Setup

### CloudWatch Alarms
```bash
#!/bin/bash
# scripts/setup-production-monitoring.sh

set -e
source scripts/common-functions.sh

log_section "Production Monitoring Setup"

# Configuration
FUNCTION_NAME="coderipple-orchestrator-prod"
SNS_TOPIC_ARN="${SNS_ALERT_TOPIC_ARN}"

# Create error rate alarm
create_error_rate_alarm() {
    log_step "Creating error rate alarm"
    
    aws cloudwatch put-metric-alarm \
        --alarm-name "CodeRipple-ErrorRate-Prod" \
        --alarm-description "CodeRipple function error rate too high" \
        --metric-name Errors \
        --namespace AWS/Lambda \
        --statistic Sum \
        --period 300 \
        --threshold 5 \
        --comparison-operator GreaterThanThreshold \
        --evaluation-periods 2 \
        --alarm-actions "$SNS_TOPIC_ARN" \
        --dimensions Name=FunctionName,Value="$FUNCTION_NAME" \
        --region "$AWS_REGION"
    
    log_success "Error rate alarm created"
}

# Create duration alarm
create_duration_alarm() {
    log_step "Creating duration alarm"
    
    aws cloudwatch put-metric-alarm \
        --alarm-name "CodeRipple-Duration-Prod" \
        --alarm-description "CodeRipple function duration too high" \
        --metric-name Duration \
        --namespace AWS/Lambda \
        --statistic Average \
        --period 300 \
        --threshold 60000 \
        --comparison-operator GreaterThanThreshold \
        --evaluation-periods 2 \
        --alarm-actions "$SNS_TOPIC_ARN" \
        --dimensions Name=FunctionName,Value="$FUNCTION_NAME" \
        --region "$AWS_REGION"
    
    log_success "Duration alarm created"
}

# Create throttle alarm
create_throttle_alarm() {
    log_step "Creating throttle alarm"
    
    aws cloudwatch put-metric-alarm \
        --alarm-name "CodeRipple-Throttles-Prod" \
        --alarm-description "CodeRipple function being throttled" \
        --metric-name Throttles \
        --namespace AWS/Lambda \
        --statistic Sum \
        --period 300 \
        --threshold 1 \
        --comparison-operator GreaterThanOrEqualToThreshold \
        --evaluation-periods 1 \
        --alarm-actions "$SNS_TOPIC_ARN" \
        --dimensions Name=FunctionName,Value="$FUNCTION_NAME" \
        --region "$AWS_REGION"
    
    log_success "Throttle alarm created"
}

# Execute monitoring setup
if [ -n "$SNS_TOPIC_ARN" ]; then
    create_error_rate_alarm
    create_duration_alarm
    create_throttle_alarm
else
    log_warning "SNS_ALERT_TOPIC_ARN not set, skipping alarm creation"
fi

log_section_complete "Production Monitoring Setup"
```

## Rollback Procedures

### Layer Rollback Script
```bash
#!/bin/bash
# scripts/rollback-layers.sh

set -e
source scripts/common-functions.sh

log_section "Layer Rollback Procedure"

# Configuration
ENVIRONMENT="production"
FUNCTION_NAME="coderipple-orchestrator-prod"

# Get previous layer versions
get_previous_layer_versions() {
    log_step "Getting previous layer versions"
    
    # Get dependencies layer versions
    DEPS_VERSIONS=$(aws lambda list-layer-versions \
        --layer-name "coderipple-dependencies-prod" \
        --region "$AWS_REGION" \
        --query 'LayerVersions[1:3].[Version,LayerVersionArn]' \
        --output text)
    
    # Get package layer versions  
    PKG_VERSIONS=$(aws lambda list-layer-versions \
        --layer-name "coderipple-package-prod" \
        --region "$AWS_REGION" \
        --query 'LayerVersions[1:3].[Version,LayerVersionArn]' \
        --output text)
    
    log_debug "Available dependency layer versions:"
    echo "$DEPS_VERSIONS"
    log_debug "Available package layer versions:"
    echo "$PKG_VERSIONS"
}

# Rollback to previous layer versions
rollback_layers() {
    log_step "Rolling back to previous layer versions"
    
    # Get previous versions (second most recent)
    PREV_DEPS_ARN=$(aws lambda list-layer-versions \
        --layer-name "coderipple-dependencies-prod" \
        --region "$AWS_REGION" \
        --query 'LayerVersions[1].LayerVersionArn' \
        --output text)
    
    PREV_PKG_ARN=$(aws lambda list-layer-versions \
        --layer-name "coderipple-package-prod" \
        --region "$AWS_REGION" \
        --query 'LayerVersions[1].LayerVersionArn' \
        --output text)
    
    if [ "$PREV_DEPS_ARN" != "None" ] && [ "$PREV_PKG_ARN" != "None" ]; then
        # Update function with previous layer versions
        aws lambda update-function-configuration \
            --function-name "$FUNCTION_NAME" \
            --layers "$PREV_DEPS_ARN" "$PREV_PKG_ARN" \
            --region "$AWS_REGION" > /dev/null
        
        log_success "Function rolled back to previous layer versions"
        log_debug "Dependencies layer: $PREV_DEPS_ARN"
        log_debug "Package layer: $PREV_PKG_ARN"
        
        # Update deployment manifest
        echo "$PREV_DEPS_ARN" > deployment/dependencies-layer-arn.txt
        echo "$PREV_PKG_ARN" > deployment/package-layer-arn.txt
        
    else
        log_error "Previous layer versions not found"
        exit 1
    fi
}

# Validate rollback
validate_rollback() {
    log_step "Validating rollback"
    
    # Test function with rolled back layers
    TEST_RESULT=$(aws lambda invoke \
        --function-name "$FUNCTION_NAME" \
        --payload '{"test": "rollback_validation"}' \
        --region "$AWS_REGION" \
        deployment/rollback-test-result.json \
        --query 'StatusCode' \
        --output text)
    
    if [ "$TEST_RESULT" = "200" ]; then
        log_success "Rollback validation successful"
    else
        log_error "Rollback validation failed"
        cat deployment/rollback-test-result.json
        exit 1
    fi
    
    rm -f deployment/rollback-test-result.json
}

# Execute rollback
get_previous_layer_versions
rollback_layers
validate_rollback

log_section_complete "Layer Rollback"
```

## Production Deployment Checklist

### Pre-Deployment Validation
- [ ] All layers built and validated locally
- [ ] Function code tested with layers
- [ ] Terraform configuration reviewed
- [ ] Environment variables configured
- [ ] IAM roles and permissions verified
- [ ] Monitoring and alerting configured

### Deployment Execution
- [ ] Dependencies layer deployed to production
- [ ] Package layer deployed to production
- [ ] Layer functionality validated in production
- [ ] Function deployed with layer attachments
- [ ] API Gateway integration updated
- [ ] End-to-end webhook processing tested

### Post-Deployment Validation
- [ ] Function invocation successful
- [ ] Layer imports working correctly
- [ ] Performance metrics within acceptable limits
- [ ] CloudWatch logs and monitoring active
- [ ] Error rates and alerts configured
- [ ] Rollback procedures tested and documented

## Expected Production Benefits

### Performance Improvements
- **99.6% package size reduction**: ~100KB function vs 28MB+ monolithic
- **Faster deployments**: Function code only, layers cached
- **Improved cold start**: Smaller packages, layer caching
- **Better resource utilization**: Optimized memory allocation

### Operational Advantages
- **Simplified deployments**: No complex package path resolution
- **Independent layer updates**: Dependencies and code updated separately
- **Better monitoring**: Clear separation of function vs dependency issues
- **Faster troubleshooting**: Isolated layer and function testing

### Reliability Improvements
- **Reduced deployment failures**: Simpler deployment process
- **Better rollback procedures**: Layer-level rollback capability
- **Enhanced monitoring**: Comprehensive alerting and observability
- **Improved error isolation**: Clear separation of concerns

## Success Metrics

### Technical Metrics
- **Deployment time reduction**: >80% faster deployments
- **Package size reduction**: >99% smaller function packages
- **Cold start improvement**: <50% faster cold starts
- **Error rate**: <1% deployment failures

### Operational Metrics
- **Mean Time to Recovery (MTTR)**: <5 minutes for rollbacks
- **Deployment frequency**: Daily deployments possible
- **Monitoring coverage**: 100% function and layer monitoring
- **Alert response time**: <2 minutes for critical issues

## Next Steps

1. **Execute production deployment**: Deploy layers and functions to production
2. **Validate production functionality**: Comprehensive end-to-end testing
3. **Monitor production performance**: Establish baseline metrics
4. **Document operational procedures**: Deployment, monitoring, and rollback guides
5. **Plan multi-Lambda migration**: Prepare for individual agent functions

---

**Status**: ✅ **COMPLETE** - Production deployment strategy with comprehensive validation, monitoring, rollback procedures, and success metrics for Lambda Layers architecture.
